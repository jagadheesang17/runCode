import { BrowserContext, Page, expect } from "@playwright/test";
import { URLConstants } from "../constants/urlConstants";
import { PlaywrightWrapper } from "../utils/playwright";
//import { credentialConstants } from "../constants/credentialConstants (Do not use)";
import { credentials } from "../constants/credentialData";
import fs from 'fs';
import path from 'path';
import { setupCourseCreation } from '../utils/cookieSetup';

export class AdminLogin extends PlaywrightWrapper {

    static pageUrl = URLConstants.adminURL;

    constructor(page: Page, context: BrowserContext) {
        super(page, context);
    }

    /**
     * Load cookies from cookies.json file generated by global-setup
     * Uses Playwright's native JSON format for reliable cookie handling
     * Note: Cookies work for all admin roles that share the same credentials
     */
    protected async loadCookiesFromFile(role: string): Promise<boolean> {
        try {
            // Admin roles that share the same credentials and can use cookie authentication
            const cookieEnabledRoles = [
                'CUSTOMERADMIN',
                'CUSTOMERADMIN1',
                'LEARNERADMIN',
                'COMMERCEADMIN',
                'SUPERADMIN',
                'PEOPLEADMIN',
                'ENROLLADMIN'
            ];

            // Only use cookies for admin roles that share credentials
            if (!cookieEnabledRoles.includes(role)) {
                console.log(`‚ÑπÔ∏è Skipping cookie auth for ${role} (only works for admin roles)`);
                return false;
            }

            const cookieFile = path.join(process.cwd(), 'data', 'cookies.json');
            
            if (!fs.existsSync(cookieFile)) {
                console.log(`No cookie file found at ${cookieFile}`);
                return false;
            }

            const cookieData = fs.readFileSync(cookieFile, 'utf-8').trim();
            
            if (!cookieData) {
                console.log('Cookie file is empty');
                return false;
            }

            // Parse cookies from JSON (Playwright native format)
            const cookies = JSON.parse(cookieData);
            
            if (!cookies || cookies.length === 0) {
                console.log('No cookies found in file');
                return false;
            }

            // Add cookies directly - they're already in the correct format
            await this.context.addCookies(cookies);
            console.log(`‚úÖ Loaded ${cookies.length} cookies from cookies.json for ${role}`);
            return true;
        } catch (error: any) {
            console.log('Failed to load cookies:', error.message);
            return false;
        }
    }

    /**
     * Verify if the current cookies are still valid
     */
    protected async verifyCookiesValid(): Promise<boolean> {
        try {
            const pageTitle = await this.getTitle();
            const currentUrl = this.page.url();
            
            // If we're on sign-in page or title contains signin, cookies are invalid
            if (pageTitle.toLowerCase().includes("signin") || 
                pageTitle.toLowerCase().includes("sign in") ||
                currentUrl.toLowerCase().includes("signin")) {
                console.log("Cookies are invalid - on sign-in page");
                return false;
            }
            
            console.log("‚úÖ Cookies are valid - authenticated");
            return true;
        } catch (error) {
            console.log("Cookie verification failed:", error);
            return false;
        }
    }

    /**
     * Regenerate fresh cookies using existing setupCourseCreation function
     */
    protected async regenerateCookies(role: string): Promise<boolean> {
        try {
            console.log(`üîÑ Regenerating fresh cookies for ${role}...`);
            
            // Use the existing cookie setup function
            await setupCourseCreation();
            
            console.log(`‚úÖ Fresh cookies regenerated for ${role}`);
            return true;
        } catch (error) {
            console.error(`‚ùå Failed to regenerate cookies for ${role}:`, error);
            return false;
        }
    }

    public async adminLogin(role: string) {
        const { username, password } = credentials[role];
        console.log("Starting admin login process...");
        await this.page.click("//span[text()='Sign In']")
        //await this.page.goto(AdminLogin.pageUrl); ----
        await this.clearAndType("#username", "Username", username);
        // Clear existing value and type password
        await this.clearAndType("#password", "Password", password);
        console.log("Clicking Sign In button...");
        // Wait for sign in button to be stable and clickable
        const signInButton = this.page.locator("//button[contains(text(),'Sign In')]");
        // await signInButton.waitFor({ state: 'visible' });
        // await signInButton.waitFor({ state: 'attached' });
         await signInButton.click({ timeout: 10000 });
        
        // Click sign in button with retry mechanism
        // try {
        //     await signInButton.click({ timeout: 10000 });
        // } catch (error) {
        //     console.log("First click failed, trying alternative selector...");
        //     await this.page.locator("button[type='submit']").click({ timeout: 10000 });
        // }
        
        await this.wait('minWait');
        /*    const logoutButton = this.page.locator("//div[@class='logout']");
   
           //console.log("Storing state...");
           //await this.storeState("./logins/expertusAdminLog.json"); */
    }

    public async singleLogin(username: string, password?: string) {

        console.log("Starting admin login process...");
        await this.clearAndType("#username", "Username", username);
        await this.clearAndType("#password", "Password", "Welcome1@");
        console.log("Clicking Sign In button...");
        await Promise.all([
            this.page.locator("//button[contains(text(),'SIGN')]").click(),
            this.wait('minWait')
        ]);
    }


    private async clearAndType(selector: string, fieldName: string, value: string) {
        console.log(`Clearing and typing into ${fieldName}...`);
        const element = this.page.locator(selector);

        // Clear any existing value
        await element.evaluate((node: HTMLInputElement) => { node.value = ''; });

        await element.type(value);
        console.log(`${fieldName} set to ${value}`);
    }
}
